Golang Cheat Sheet

===========
25 Keywords
===========

break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var

==========================
Type declaration (structs)
==========================
A struct's fields usually represent the "has-a" relationship. For example a Circle has an x,y location and a radius. 

type Circle struct {
  x float64
  y float64
  r float64
}
	==or==
type Circle struct {
  x, y, r float64
}

==============
Embedded Types (inheritance)
==============
Embedded types within a struct can be used to represent the "is-a" relationship 

type Person struct {
  Name string
}
func (p *Person) Talk() {
  fmt.Println("Hi, my name is", p.Name)
}

type Android struct {
  Person		//an embedded type without a name represents the "is-a" relationship (an Android is-a type of Person)
  Model string
}
a := Android{name: "R2D2"}
a.Talk()

==========================
Initialization/Declaration (different ways)
==========================

var f *Circle = new(Circle) //creates a Circle variable that is by default set to zero
                            //function new(T) returns a pointer to a newly allocated zero value of type T

var c Circle		            //creates a Circle variable that is by default set to zero

var c = Circle{x: 0, y: 0, r: 5}

--- short form --- (ONLY inside of functions)
c := new(Circle)	//allocates memory for all the fields, sets them all to their zero value and returns a pointer (*Circle) 

c := Circle{x: 0, y: 0, r: 5}	//allocates memory, sets all the values, and returns a pointer (*Circle)

The following are 3 equivalent ways to create an object and return a pointer to the object's address
    // Allocate enough memory to store a bytes.Buffer value and return a pointer to the value's address.
    var buf bytes.Buffer
    p := &buf

    // Use a composite literal to perform allocation and return a pointer to the value's address.
    p := &bytes.Buffer{}

    // Use the new() function to perform allocation, which will return a pointer to the value's address.
    p := new(bytes.Buffer)

===============
new() vs make()
===============

new():  The built-in function new(T) allocates “zeroed” storage for a new item of type T.
        It returns a pointer to a newly allocated zero value of type T. 

make(): The built-in function make(T, args) is used to create slices, maps, and channels only.
        It returns an initialized (not zeroed) value of type T (not *T). 

        // Idiomatic:
        v = make([]int, 10, 100)  //allocates an array of 100 ints and then creates a slice structure with length 10 and a 
                                    capacity of 100 pointing at the first 10 elements of the array. 
        v := make([]int, 10)     //the capacity can be omitted

        make(map[string]int)        //makes a map of string (keys) to int (values)
        make(map[string]int, 100)   //optional size: initial size 100 (that grows automatically)

        make(chan int)              //makes a channel
        make(chan int, 100)         //optional capacity 100

=================
Arrays and Slices
=================

        Because slices are variable-length, it is possible to have each inner slice be a different length. 

        text := LinesOfText{
          []byte("Now is the time"),
          []byte("for all good gophers"),
          []byte("to bring some fun to the party."),
        }

        // Example of a 2-Dimensional Array/Slice (for a transformation matrix)
        type Transform [3][3]float64  // A 3x3 array, really an array of arrays. 

        // Example of a 2-Dimensional Array/Slice to store array of pixels for a picture
        // Allocate the top-level slice
        picture := make([][]uint8, YSize) // One row per unit of y.
        // Loop over the rows, allocating the slice for each row.
        for i := range picture {
          picture[i] = make([]uint8, XSize)
        }

=========
Functions
=========
// this function cannot modify the given Circle argument (because arguments are always copied in Go)
func circleArea(c Circle) float64 {
  return math.Pi * c.r*c.r
}

fmt.Println(circleArea(c))

// in order to allow the function to modify the argument, it must be specified as a pointer, like this 
func circleArea(c *Circle) float64 {
  return math.Pi * c.r*c.r
}

fmt.Println(circleArea(&c))

=======
Methods (have receivers: Pointer Receivers or Value Receivers) 
=======
A special type of go function is known as a Method. 
Methods have a "receiver" type specified between the keyword "func" and the name of the function. 

// Value Receiver -- this method cannot modify the given Circle argument 
func (c Circle) area() float64 {
  return math.Pi * c.r*c.r
}

// Pointer Receiver -- this method CAN modify the given Circle argument 
func (c *Circle) Area() float64 {
  return math.Pi * c.r*c.r
}

By creating the function in this way it allows us to call the function using the . operator:

fmt.Println(c.area())
 ==or==
fmt.Println((&c).Area())

This is easier to read, we no longer need the & operator (Go automatically knows to pass a pointer to the circle)


=========
for loops
=========
The for loop is the only loop statement in Go. It has a number of forms.

for initialization; condition; post {
  // zero or more statements
}

// a traditional "while" loop
for condition {
  // ...
}

// a traditional infinite loop
for {
  // ...
}

=======================
Printf Escape Sequences
=======================

The default format for %v is:

bool:                    %t
int, int8 etc.:          %d
uint, uint8 etc.:        %d, %#x if printed with %#v
float32, complex64, etc: %g
string:                  %s
chan:                    %p
pointer:                 %p

